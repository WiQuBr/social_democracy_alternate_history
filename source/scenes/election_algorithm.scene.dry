title: Election
on-arrival: on-arrival: {!

    function redistribute(from_party, base_rules) {
        for (var c of Q.classes) {
            var original = Q[c + '_' + from_party];
            if (!original || original === 0) continue;

            var rules = Object.assign({}, base_rules);

            // Apply 5%-threshold rule
            if (Q.electoral_threshold >= 5) {
                if (rules.other) {
                    rules.other *= 0.6;
                    rules.spd = (rules.spd || 0) + 0.2;
                    rules.zentrum = (rules.zentrum || 0) + 0.2;
                }
            }

            // Normalize
            var total = 0;
            for (var t in rules) total += rules[t];
            for (var t in rules) rules[t] /= total;

            // Distribute
            for (var t in rules) {
                Q[c + '_' + t] += original * rules[t];
            }

            Q[c + '_' + from_party] = 0;
        }
    }

    if (Q.kpd_banned) {
        var base_kpd;
        if (!Q.nsdap_banned) {
            base_kpd = { spd: 0.6, other: 0.3, zentrum: 0.1 };
        } else {
            base_kpd = { spd: 0.75, other: 0.15, zentrum: 0.1 };
        }
        redistribute('kpd', base_kpd);
    }

    if (Q.nsdap_banned) {
        var base_nsdap;
        if (!Q.dnvp_banned) {
            base_nsdap = { dnvp: 0.5, dvp: 0.2, other: 0.3 };
        } else {
            base_nsdap = { dvp: 0.5, zentrum: 0.2, other: 0.3 };
        }
        redistribute('nsdap', base_nsdap);
    }

    if (Q.dnvp_banned) {
        var base_dnvp;
        base_dnvp = Q.dvp_banned ? { zentrum: 0.6, other: 0.4 } : { dvp: 0.4, zentrum: 0.4, other: 0.2 };
        redistribute('dnvp', base_dnvp);
    }

!}

{!
// calculate normalized class voting amounts (0 to 100)
for (var c of Q.classes) {
    var class_votes = 0;
    for (var party of Q.parties) {
        if (Q[c+'_'+party] < 0) {
            Q[c+'_'+party] = 0;
        }
        class_votes += Q[c+'_'+party];
    }
    for (var party of Q.parties) {
        Q[c + '_' + party + '_normalized'] = 100*Q[c+'_'+party]/class_votes;
        Q[c + '_' + party + '_display'] = Math.round(100*Q[c+'_'+party]/class_votes);
    }
}

// 1. calculate support for each of the parties
var total_support = 0;
for (var party of Q.parties) {
    var party_support = 0;
    for (var c of Q.classes) {
        // but this version is somewhat more entertaining and allows for wilder swings in votes.
        // the other option basically necessitates a multi-class strategy. while the first option allows for a working-class-only strategy.
        if (Q.old_demographics) {
            // okay i'm pretty sure this is wrong, and the hard version is correct
            // basically this allows for "spillover" effects in other demographics.
            // so you can campaign among say the workers and 
            party_support += Q[c]*Q[c+'_'+party];
            // However, there should be a cap on how much party support you can get in a certain demo.
        } else  {
            party_support += Q[c]*Q[c+'_'+party+'_normalized'];
        }
    }
    Q[party + '_support'] = party_support;
    total_support += party_support;
}
// 2. normalize support (fraction)
// 3. Round to integers
// TODO: round to 1 decimal instead of rounding to integers
// to do that, we multiply party_normalized*1000 and divide the rounded number by 10.
for (var party of Q.parties) {
    Q[party+'_normalized'] = Q[party + '_support']/total_support;
    Q[party+'_votes_dec'] = Math.round(Q[party+'_normalized']*1000)/10;
    if (Q.use_decimals) {
        Q[party+'_votes'] = Q[party+'_votes_dec'];
        Q[party + '_votes_disp'] = Q[party+'_votes'];
    } else {
        Q[party+'_votes'] = Math.round(Q[party+'_normalized']*100);
        Q[party + '_votes_disp'] = Q[party+'_votes_dec'].toFixed(1);
    }
    //Q[party+'_votes'] = Q[party+'_votes_dec'];
    // display
}
!}

go-to: jumpScene

# note: this is a helpful utility to deal with elections and so on.